 when using React Router. We call it “Dynamic Routing”, which is quite different from the “Static Routing
 
 Static Routing
If you’ve used Rails, Express, Ember, Angular etc. you’ve used static routing. In these frameworks, you declare your routes as part of your app’s initialization before any rendering takes place.
react router pre - v4 was static
Dynamic Routing
When we say dynamic routing, we mean routing that takes place as your app is rendering, not in a configuration or convention outside of a running app. 

As the user rotates their phone from portrait to landscape, this code will automatically redirect them to the dashboard. The set of valid routes change depending on the dynamic nature of a mobile device in a user’s hands.
When routing is dynamic, however, you can declaratively compose this functionality. If you start thinking about routing as UI, not as static configuration, your intuition will lead you

react-router-dom provides <BrowserRouter> and <HashRouter> routers. Both of these will create a specialized history object for you. Generally speaking, you should use a <BrowserRouter> if you have a server that responds to requests and a <HashRouter> if you are using a static file server.
Route matching is done by comparing a <Route>'s path prop to the current location’s pathname. When a <Route> matches it will render its content and when it does not match, it will render null.

React Router provides a <Link> component to create links in your application. Wherever you render a <Link>, an anchor (<a>) will be rendered in your application’s HTML
The <NavLink> is a special type of <Link> that can style itself as “active” when its to prop matches the current location.
Any time that you want to force navigation, you can render a <Redirect>. When a <Redirect> renders, it will navigate using its to prop.

React Router exports the matchPath static function that it uses internally to match locations to routes. You can use this function on the server to help determine what your data dependencies will be before rendering.

React vs angular 
Angular is a framework while react is library
Your code calls the library while the framework calls your code.

This is also known as Inversion of Control. The litmus test for detecting a framework is checking if it has the Inversion of Control.
Inversion of control is a design principle in which code receive the flow of control from a generic framework.

Angular is a TypeScript-based, open-source front-end web application platform. It is an MVC framework created by Google.
React is a JavaScript library for building user interfaces. Created by Facebook, Instagram, and the community

Data Binding
Angular allows two-way data binding while React allows one-way data binding.

Angular uses the browser's DOM, while React uses a virtual DOM.

By using a virtual DOM, you can change any element very quickly and without needing to render the whole DOM.
Imagine the difference in performance in needing to render all 100 items when just a single item is changed, then just rendering a single changed item and not rendering the rest.


 The middleware sits in between the dispatch and reducers, which means we can alter our dispatched actions before they get to the reducers or execute some code during the dispatch.
 middleware receives a store, then returns a function that receives a next function and returns another function that receives an action.
 The Next: We call this function when our middleware is done with the task assigned to do. This sends our actions to our reducer or another middleware.
 when I click on this button I want to save this age on on to the server once I have confirmation that it has been saved on the server then only I want to update my state because that only makes sense when you to update it when it saves on the server.  let's say if there's an error you want to basically exit out and cancel the action ok so in the current situation in a simple current situation you cannot do this because if you try to run anything asynchronous in the reducer it won't work we it's designed to run synchronous code and so we have a problem so we need 
something where we can actually catch the action in the middle do our operation of saving or whatever we want to do and then once it's done then we want to continue with that action to the reducer to update the state. 

 
If document type is not mentioned, browser will go to Quirks mode. Quirks mode depends upon the web browser version, If is older version then this will not support HTML5 tags


react 16.4.1
redux 3.6
webpack 4.16


Jest 

import React from 'react';
import { mount, shallow } from 'enzyme';
import sinon from 'sinon';

let props={};
function setUp(){
categoryMainViewWrapper = shallow(<Results {...props} />);
	instance = categoryMainViewWrapper.instance(); 
	
	return {categoryMainViewWrapper};
}

categoryMainViewWrapper = setup();
describe('Category Main Component testing', () => {

	it('should check if component exists', () => {
		expect(categoryMainViewWrapper).toBeDefined();
		}
		
	it('should call isValidFaqRequest function without breaking', function () {
		let isValidFaqRequestSpy = sinon.spy(instance, 'isValidFaqRequest');   //isValidFaqRequest is a function in component that takes a value and return true false
		categoryMainViewWrapper.instance().isValidFaqRequest('Support',true);
	}
	
	it('should call componentDidMount function without failing', function () {
		const spyObj = sinon.spy(instance, 'componentDidMount');
		categoryMainViewWrapper.instance().componentDidMount();
		sinon.assert.calledOnce(spyObj);
	});
	
	it('should render self and subcomponents', () => {
		expect(categoryMainViewWrapper.find('CategoryHeader').exists()).toBe(true);
		expect(categoryMainViewWrapper.find('CategoryHeader').props().categoryVal).toEqual('Support');
	});

Enzyme provides a mechanism to mount and traverse React.js component trees. This will help us get access to its own properties and state as well as its children props in order to run our assertions.
Enzyme offers two basic functions for component mounting: shallow and mount. The shallow function loads in memory only the root component whereas mount loads the full DOM tree.
We’re going to combine Enzyme and Jest to mount a React.js component and run assertions over it.

