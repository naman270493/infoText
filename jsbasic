The typeof operator returns a string indicating the type of the unevaluated operand.

var x;
undefined

typeof x=="undefined"
true
typeof x==="undefined"
true
typeof x=="undefined"
true
typeof (typeof 1) === 'string';
true
typeof /regex/ === 'object'
true
typeof null === 'object';
true

can angular app satrt without ng-app
Yes, it can 
By automatic bootstrap it can
angular.element(document).ready(function() {
	angular.bootstrap(document, ['myApp']);
});

scope: false  Directive uses its parent scope
scope:true Directive gets a new scope

restrict: EA - this occurs in directive then we can use elemnet as both 
like in case restrict: 'E' then if we declare directive as attribute then angular with throw an error
by EA we can use it like elemnet and attribute both (by default EA)



Compile function

Each directive's compile function is only called once, when Angular bootstraps.

Primarily, this is done for optimisation purposes; consider the following markup:

<tr ng-repeat="raw in raws">
    <my-raw></my-raw>
</tr>
The <my-raw> directive will render a particular set of DOM markup. So we can either:

Allow ng-repeat to duplicate the source template (<my-raw>), and then modify the markup of each instance template (outside the compile function).
Modify the source template to involve the desired markup (in the compile function), and then allow ng-repeat to duplicate it.
If there are 1000 items in the raws collection, the latter option may be faster than the former one.

Closure means that an inner function always has access to the vars and parameters of its outer function, even after the outer function has returned. Therefore, you can call the inner function later in your program.
A closure is a function that has access to the parent scope, even after the scope has closed.
The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.
Closures store references to the outer function’s variables; they do not store the actual value. ?Because closures have access to the updated values of the outer function’s variables, they can also lead to bugs when the outer function’s variable changes with a for loop.
For this we use IIFE.

let x= "hi";
let y ="ih";

const reverString = (str) => {
	str.split('').reverse().join('');
}
console.log(reverString(x));


var obj= {
 a:1,
 b:2,
 getA(){ console.log(this.a);},
 getB(){ console.log(this.a);}

}

obj.getA().getB();
// to get this u need to return this from get A
getA(){ 
	console.log(this.a);
	 return this;
	}
	
Function properties - 
The eval() function evaluates JavaScript code represented as a string.
The argument of the eval() function is a string.
eval(new String('2 + 2')); // returns a String object containing "2 + 2"
eval('2 + 2');             // returns 4

The uneval() function creates a string representation of the source code of an Object.
var a = 1;
uneval(a); // returns a String containing 1

var b = '1';
uneval(b); // returns a String containing "1"



JSON.parse() - The JSON.parse() method parses a JSON string, constructing the JavaScript object 
var json = '{"result":true, "count":42}'; this is a json
obj = JSON.parse(json);

//Object {result: true, count: 42}

The JSON.stringify() method converts a JavaScript Object to a JSON string
var obj = { x: 5, y: 6 };
var json = JSON.stringify(obj);

console.log(json);
// {"x":5,"y":6}

If a variable that is neither declared nor defined, when we try to reference such a variable we'd get the result not defined.
while if variable is declared but not defined its undefined

Objects can be accessed using dot operator but property must be a valid JavaScript identifier, that cannot start with a number
Objects can be accessed with bracket notation also. Objects are sometimes called associative arrays, since each property is associated with a string value that can be used to access it. 
The string does not have to be a valid identifier; it can have any value, e.g. "1foo", "!bar!", or even " " (a space)

var obj = { 
           prop: "name",          
          }
var x="prop";

obj.x //undefined
obj[x] //name
When you use dot notation, JS is thinking you are looking for a key whose value is a string of whatever is after the dot
In bracket notation the expression in the square brackets is evaluated and its toString() method called. It is that value that is used as the property name

code for event delegation 

Event delegation allows you to avoid adding event listeners to specific nodes;  instead, the event listener is added to one parent.  That event listener analyzes bubbled events to find a match on child elements.

document.addEventListener('DOMContentLoaded', function() {
  
  let app = document.getElementById('todo-app');
  
  // attach event listener to whole container
  app.addEventListener('click', function(e) {
    if (e.target && e.target.nodeName === 'LI') {
      let item = e.target;
      alert('you clicked on item: ' + item.innerHTML);
    }
  });
  
});

