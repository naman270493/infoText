let x= "hi";
let y ="ih";

const reverString = (str) => {
	str.split('').reverse().join('');
}
console.log(reverString(x));


var obj= {
 a:1,
 b:2,
 getA(){ console.log(this.a);},
 getB(){ console.log(this.a);}

}

obj.getA().getB();
// to get this u need to return this from get A
getA(){ 
	console.log(this.a);
	 return this;
	}
	
Function properties - 
The eval() function evaluates JavaScript code represented as a string.
The argument of the eval() function is a string.
eval(new String('2 + 2')); // returns a String object containing "2 + 2"
eval('2 + 2');             // returns 4

The uneval() function creates a string representation of the source code of an Object.
var a = 1;
uneval(a); // returns a String containing 1

var b = '1';
uneval(b); // returns a String containing "1"



JSON.parse() - The JSON.parse() method parses a JSON string, constructing the JavaScript object 
var json = '{"result":true, "count":42}'; this is a json
obj = JSON.parse(json);

//Object {result: true, count: 42}

The JSON.stringify() method converts a JavaScript Object to a JSON string
var obj = { x: 5, y: 6 };
var json = JSON.stringify(obj);

console.log(json);
// {"x":5,"y":6}

If a variable that is neither declared nor defined, when we try to reference such a variable we'd get the result not defined.
while if variable is declared but not defined its undefined

Objects can be accessed using dot operator but property must be a valid JavaScript identifier, that cannot start with a number
Objects can be accessed with bracket notation also. Objects are sometimes called associative arrays, since each property is associated with a string value that can be used to access it. 
The string does not have to be a valid identifier; it can have any value, e.g. "1foo", "!bar!", or even " " (a space)

var obj = { 
           prop: "name",          
          }
var x="prop";

obj.x //undefined
obj[x] //name
When you use dot notation, JS is thinking you are looking for a key whose value is a string of whatever is after the dot
In bracket notation the expression in the square brackets is evaluated and its toString() method called. It is that value that is used as the property name

code for event delegation 

Event delegation allows you to avoid adding event listeners to specific nodes;  instead, the event listener is added to one parent.  That event listener analyzes bubbled events to find a match on child elements.

document.addEventListener('DOMContentLoaded', function() {
  
  let app = document.getElementById('todo-app');
  
  // attach event listener to whole container
  app.addEventListener('click', function(e) {
    if (e.target && e.target.nodeName === 'LI') {
      let item = e.target;
      alert('you clicked on item: ' + item.innerHTML);
    }
  });
  
});

