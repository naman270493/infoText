The separation of concerns is achieved by dividing each AngularJS application into separate components, such as:

partials
controllers
directives
services
filters

The separation of concerns is keeping the code for each of these concerns separate. Changing the interface should not require changing the business logic code, and vice versa.

Model-View-Controller (MVC) design pattern is an excellent example of separating these concerns for better software maintainability.

The AngularJS Directive of ng-include is used to get a fragment of HTML block from an outside source, and process the directives within in and Add to the Main Document.

Filters are used to format or transform value of expression for display to the user. They can be added to templates, controllers, directives or services and you can also define your own filters. 
To Invoke a filter user the character | (pipe)
we can invoke a filter on both the data binding in your html or directly inside of your controller or directive by using the $filter service.

<p>The name is {{ lastName | uppercase }}</p>

//controller
angular.module('filterExample', [])
.controller('MainCtrl', function($scope, $filter) {
  $scope.originalText = 'hello';
  $scope.filteredText = $filter('uppercase')($scope.originalText);
});

<div ng-controller="MainCtrl">
 <h3>{{ originalText }}</h3>
 <h3>{{ filteredText }}</h3>
</div>


custom filter

<div>{{name|titlecase}}</div>

angular.module('CustomFilterModule', [])
       .filter( 'titlecase', function() {
return function( input ) {
       return input.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
}
});


Providers
whatever we can do with services and factory can be done with provider with more flexibility

app.provider('date', function(){
	return{ //this return returns provider a value
			$get: function(){
			
				return{		//this return returns injector a value
				showDate: function(){
					var date= new Date();
					return date.getHours();  
				}
				}
			}
	}
});

app.controller('ctrl', function($scope, date){
 $scope.timing = date.showDate();
});

-- 

app.provider('date', function(){
	return{ //this return returns provider a value
			var greet;
			setGreeting : function(){ //create setgreeting as private function, i dont want it to be executed by injector, this can be accessed in app.config only
					
					greet = value;
				},
	
			$get: function(){
				return{		//this return returns injector a value
				showDate: function(){
					var date= new Date();
					return date.getHours();  
				}
				}
			}
	}
});

app.config(function(dateProvider){
	var time = dateProvider.$get().showdate();
	if(time>0 && time<5){ dateProvider.setGreeting("Morning");}

}); //you can only access providers in config block and nothing else

app.controller('ctrl', function($scope, date){
 $scope.timing = date.showDate();
});

this will automatically create dateProvider in your application.config()
we return code inside date to the injector, innjector do wat controllers are doing 

less code in service than factory
you can return any kind of value in factory not in services, provider give aceess to config tah

Angular js in design pattern 
When given dependency is required by any component, AngularJS resolves it using the following algorithm
look into defined into a lexical closure
If the dependency exists AngularJS pass it as parameter to the component
 If the dependency does not exists:
AngularJS instantiate it by calling the factory method of its provider (i.e. $get).

1. each service as a singleton, because each service is instantiated no more than a single time. 
2. factory service in angular
3. The decorator pattern (also known as Wrapper, an alternative naming shared with the Adapter pattern) is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class.
Using the method decorator of $provide you can create "wrapper" of any service you have previously defined or used by a third-party

app.config(function($provide){
	$provide.decorator('emailService', function($delegate){
		$delegate.sendSign = function(signature){
			return 'sending'+signature;
		};
		
		return $delegate;
	
	})
});

app.controller('Ctrl', function($scope, emailService){
		$scope.email = emailService.sendSign("abc@gmail.com");
});

4. $http, $resource are facade pattern
5. MVC iscombination of startegy, composite and observer
6. scope as observer pattern
7. Template View
Renders information into HTML by embedding markers in an HTML page.


Benefits of using Webpack.
It bundles your multiple modules and packs it into a single .js file.
It comes with integrated dev server. A small express app for local development. You simply include one Javascript tag pointed to the server, like localhost:8080/assets/bundle.js, and get live code updating and asset management for free.

Destructuring is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.
var a, b, rest;
[a, b] = [10, 20];

console.log(a);
// expected output: 10

console.log(b);
// expected output: 20

[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(rest);
// expected output: [30,40,50]

ES6 is finalized, but not fully supported by all browsers (e.g., ES6 Firefox support). To use ES6, we need to use a compiler like Babel. You can run it as a standalone tool or use with your build system. 
